Ответ на вопрос №2

x86_64
Object or primitive							Lendth in bytes

int											4
Object										16
String (empty)								40

user1										64	total
											8	mark word
											8	klass oop
											4	int
											40	String (empty)
											4	padding
											
user2										72	total
											8	mark word
											8	klass oop
											4	int
											48	String (lendth = 5)
											4	padding
											
user3										80	total
											8	mark word
											8	klass oop
											4	int
											56	String (lendth = 9)
											4	padding																					
											
============================================================================

Ответ на вопрос №3

В Java все классы наследуются от класса Object. Object занимает 16 байт.
Т.о. пустой объект без полей занимает 16 байт.

=============================================================================

Ответ на вопрос №5 (см. в конце)

Мало что было понятно. Помогло видео про сбощик shenandoah от Алексея Шипилева.
Т.к. мне не до конца был ясен механизм сборки мусора (в практическом применении) - я провел небольшое
исследование. Для этого я установил плагин Visual GC, чтобы понаблюдать распределение объектов в
памяти по регионам кучи, а также оценить частоту вызова сборщика для малой и полной(старшей, смешанной) сборки мусора.
У меня установлен jdk14, Java HotSpot(TM) 64-Bit Server VM. Сборщик мусора по умолчанию - G1GC.
ЦП 4 ядра, 8 потоков.
Помимо опций -XmxNm -XmsNm я использовал -XX:+UseSerialGC, -XX:+UseParallelGC, -XX:+UseConcMarkSweepGC.

Моя программа согласилась стартовать только при минимальном размере heap - 4096 КиБ. При 2048 пишет, что
размер heap мал. При 3072 стартует, но размер heap устанавливается сам в 4096 КиБ.
При максимальном размере heap 4096 КиБ программа падала вскоре после запуска с ошибкой
java.lang.OutOfMemoryError, независимо от используемого сборщика мусора. Пришлось ввести задержку, чтобы успевало переключаться на сборщик.
Во всех случаях окончания работы программы не дожидался, работу программы останавливал принудительно.

В моей программе все создаваемые объекты User являются "мусорными", т.е. не используются.

+++++++++++++++++++ 4096 КиБ +++++++++++++++++++++++++++++++++++++++++++++

При SerialGC и максимальном размере heap 4096 КиБ регион eden используется, заполняется-очищается.
Регионы survivor использовались только вначале, ИМХО не для User объектов.
Регион tenured используется визуально на 65% (по умолчанию 65% - это такой занимаемый объем tenured,
при котором вызывается полная сборка мусора).
За ~4 минут работы программы произошло:
~355 малых сборок, общее время малых сборок составило ~25 мс,
~350 полных сборок, общее время полных сборок составило ~4280000 мс.

При ParallelGC и максимальном размере heap 4096 КиБ регион eden используется, заполняется-очищается.
Регионы survivor используются попеременно.
Регион tenured используется визуально на 88%.
За ~13 минут работы программы произошло:
~2780 малых сборок, общее время малых сборок составило ~2285 мс,
~1 полных сборок, общее время полных сборок составило ~20 мс.

При ConcMarkSweepGC и максимальном размере heap 4096 КиБ регион eden практически не наполняется.
Регионы survivor практически не используются.
Регион tenured заполняется визуально на 50%.
За ~4 минут работы программы произошло:
~405 малых сборок, общее время малых сборок составило ~1182 мс,
~400 СТАРШИХ сборок, общее время старших сборок составило ~6997 мс.

При G1GC и максимальном размере heap 4096 КиБ регионы eden практически не наполняются.
Регионы survivor практически не используются.
Регионы tenured заполняются визуально на 50%.
За ~9 минут работы программы произошло:
~860 малых сборок, общее время малых сборок составило ~2567000 мс,
~857 СМЕШАННЫХ сборок, общее время смешанных сборок составило ~14700000 мс.

+++++++++++++++++++ 65536 КиБ +++++++++++++++++++++++++++++++++++++++++++++

При SerialGC и максимальном размере heap 65536 КиБ регион eden используется, заполняется-очищается.
Регионы survivor используются попеременно, заполняются-очищаются.
Регион tenured заполнен визуально на 20%.
За ~6 минут работы программы произошло:
~260 малых сборок, общее время малых сборок составило ~485 мс,
~90 полных сборок, общее время полных сборок составило ~1058000 мс.

При ParallelGC и максимальном размере heap 65536 КиБ регион eden используется, заполняется-очищается.
Регионы survivor используются попеременно, заполняются-очищаются.
Регион tenured используется визуально на 10%.
За ~4 минут работы программы произошло:
~80 малых сборок, общее время малых сборок составило ~261 мс,
~2 полных сборок, общее время полных сборок составило ~36 мс.

При ConcMarkSweepGC и максимальном размере heap 65536 КиБ регион eden практически не наполняется.
Регион survivor0 не используются.
Регион survivor1 заполнился ~на 65% и находится в таком состоянии. 
Регион tenured медленно заполняется и частично очищается.
За ~7 минут работы программы произошло:
~717 малых сборок, общее время малых сборок составило ~1200000 мс,
~4 СТАРШИХ сборок, общее время старших сборок составило ~4 мс.

При G1GC и максимальном размере heap 65536 КиБ регионы eden практически не наполняются.
Регионы survivor заполнились ~на 65% и находятся в таком состоянии.
Регионы tenured медленно заполняются и по прошествии пары минут частично очищаются.
За ~5 минут работы программы произошло:
~512 малых сборок, общее время малых сборок составило ~875 мс,
~2 СМЕШАННЫХ сборок, общее время смешанных сборок составило ~2 мс.

+++++++++++++++++++++++++++++++ Выводы +++++++++++++++++++++++++++++++++++++++++++++

При разных сборщиках и разном размере heap получаются разные временные характеристики при сборке
мусора. Применительно к задаче, где много мусорных объектов лучшие результаты показал параллельный сборщик
при незначительном увеличении размера heap. Каждая задача требует проведения исследований для определения
оптимальных параметров сборки мусора для снижения временных издержек и повышения производительности.

Отвечая на вопрос, напишу, что в моем случае при недостатке памяти программа не запускалась по причине
"Too small maximum heap" для работы Java VM при ограничении heap 1024 КиБ. Программа при запуске падает с ошибкой
OutOfMemoryError, если heap ограничен 2048 КиБ, также программа падает с ошибкой OutOfMemoryError,
если сборщик мусора не успевает отработать при размере кучи до 1024 МиБ (1 ГиБ), при 1088 МиБ работает корректно.
При условии введения задержки выполнения потока программа выполняется корректно на куче 4096 КиБ, производительность зависит
от размера выделенной памяти и применяемого сборщика мусора.